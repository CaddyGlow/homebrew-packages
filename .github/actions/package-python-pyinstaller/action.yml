name: Package Python Binary with PyInstaller
description: Builds standalone binary with PyInstaller and creates release archive

inputs:
  binary_name:
    description: 'Name of the binary to build'
    required: true
  archive_format:
    description: 'Archive format: tar.gz or zip'
    required: true
  exe_suffix:
    description: 'Executable suffix (.exe for Windows, empty for Unix)'
    required: false
    default: ''
  assets:
    description: 'JSON array of asset paths to include'
    required: false
    default: '[]'
  entry_point:
    description: 'Python module entry point (e.g., ccproxy.cli:main)'
    required: true

runs:
  using: composite
  steps:
    - name: Install PyInstaller
      shell: bash
      run: |
        uv pip install pyinstaller

    - name: Build with PyInstaller
      shell: bash
      run: |
        BINARY_NAME="${{ inputs.binary_name }}"
        ENTRY_POINT="${{ inputs.entry_point }}"

        # Parse entry_point format (module.path:function)
        MODULE=$(echo "$ENTRY_POINT" | cut -d: -f1)
        FUNCTION=$(echo "$ENTRY_POINT" | cut -d: -f2)

        # Create a temporary entry script for PyInstaller
        cat > __pyinstaller_entry__.py <<EOF
        from ${MODULE} import ${FUNCTION}
        if __name__ == '__main__':
            ${FUNCTION}()
        EOF

        # Build standalone binary
        uv run pyinstaller \
          --onefile \
          --name "$BINARY_NAME" \
          --collect-all "$BINARY_NAME" \
          --hidden-import="$MODULE" \
          --noconfirm \
          --clean \
          __pyinstaller_entry__.py

        # Clean up temp script
        rm -f __pyinstaller_entry__.py

    - name: Package (Windows)
      if: inputs.archive_format == 'zip'
      shell: pwsh
      run: |
        $BINARY_NAME = "${{ inputs.binary_name }}"
        $ASSETS = '${{ inputs.assets }}' | ConvertFrom-Json

        New-Item -ItemType Directory -Force -Path dist-archive

        # Copy the built binary
        Copy-Item "dist/$BINARY_NAME${{ inputs.exe_suffix }}" "dist-archive/$BINARY_NAME${{ inputs.exe_suffix }}"

        # Copy assets if any
        foreach ($ASSET in $ASSETS) {
          if (Test-Path $ASSET) {
            Copy-Item $ASSET -Destination dist-archive -Recurse
          }
        }

        $ARCHIVE_NAME = "$BINARY_NAME-${env:RUNNER_ARCH}.zip"
        $itemsToCompress = Get-ChildItem -Path dist-archive -File
        Compress-Archive -Path $itemsToCompress.FullName -DestinationPath "dist/$ARCHIVE_NAME"

        Write-Output "Created archive: $ARCHIVE_NAME"
        Get-ChildItem dist

    - name: Package (Unix)
      if: inputs.archive_format != 'zip'
      shell: bash
      run: |
        mkdir -p dist-archive
        BINARY_NAME="${{ inputs.binary_name }}"
        ASSETS='${{ inputs.assets }}'

        # Copy the built binary
        cp "dist/$BINARY_NAME${{ inputs.exe_suffix }}" "dist-archive/$BINARY_NAME${{ inputs.exe_suffix }}"
        chmod +x "dist-archive/$BINARY_NAME${{ inputs.exe_suffix }}"

        # Copy assets if any
        if [ "$ASSETS" != "[]" ]; then
          echo "$ASSETS" | jq -r '.[]' | while read -r ASSET; do
            if [ -e "$ASSET" ]; then
              cp -r "$ASSET" dist-archive/
            fi
          done
        fi

        # Create archive
        cd dist-archive
        ARCHIVE_NAME="$BINARY_NAME-${RUNNER_ARCH}.tar.gz"
        tar czf "../dist/$ARCHIVE_NAME" *
        cd ..

        echo "Created archive: $ARCHIVE_NAME"
        ls -lh dist/
